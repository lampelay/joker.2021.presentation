

Рабочее название доклада звучит как
Shaken, not stirred - bunch of distributed teams in the single Spring Context



300+ - teams 
50+ - microservices

// TODO
- Саша со своей стороны посмотрит презенташки - которые воткнули уровнем предоставления инфо
- Что и как мы можем выносить наружу (Протокол WorkFlow) - после полного текста презентации просто самим вычитать и смотреть
- Найти контакты через кого кидаем на Joker - DONE
- Найти категорию (тема) в которой рассказывать на Joker - 
	Operations:
	Опыт эксплуатации и сопровождения больших систем на Java
-  



Примеры презентаций
Creating Groovy DSLs that Developers Can Actually Use
https://www.infoq.com/presentations/groovy-dsl-mars/



1. Микросервисы для бизнеса подключаются через отдельные Spring Beans
-- на стороне бизнеес-приложения это клиентское????? взаимодействие
-- клиентское взаимодействие через HTTP (как правило), или TCP (немного)

2. Каждый микросервис предоставляет одна команда

3. Какие ключевые моменты увеличивали хаос
выравнивать всех более 50 команд,
разная скорость релизов,
команды географически распределны 
в разных часовых поясах
нужно подключать
???
???
- оправдание КМов? нудно много подробностей!!!
- прийти за историей к Саше Абросимову, Денису
- КМы элементарная инфраструктурная транспортная логика и она единообразна и не нужна на уровне бизнес приложения


3. Когда не было выравнивания с какимим проблемами столкнулись
-- не стартует Spring Context
-- коллизия по именам бинов
-- минимальное количество тестов????
-- Бизнесовым командам требуется подключать N зависимостей и отслеживать их изменение номеров версий
-- Несколько версий в проде
-- несколько каналов и т.п.
-- 



// TODO  Саша напиши историю
- рассказать историю и последовательностей шагов, как пришли к первому решению




4. Первый подход к снаряду
Pros
-- выделена отдельная команда
-- организовывала и синхронизировала остальные микросервисные команды
-- получали надлежащее качество - КМов
-- появился pom bom - бизнес команда подключает единственную зависимость, не парится с пачкой
-- бизнесовые команды привыкли и приняли удобство подключения
-- выкрестализовывание примера для бизнес команд
-- ???
-- ???

Cons
-- долгий процесс пинания команд, каждая в своем релизном цикле, рассинхрон
-- необязательность и не требуемая????
-- появилась иллюзия, что эта команда полностью отвечает за поставку ане команда ТСов
-- разруливание в полуручном режиме коллизий, сведенеие нескольких команд в одном диалоге
-- команда КМа явно не видит проблем и коллизий!!
-- ??



5. Описать новый подход - Blinding Lights
-- Чтобы команда микросевиса попала, а бизнесу предоставляется pom bom






# Преза

## История Синтетики
- Была платформа и были КМы
- КМы
  - не нужно думать о транспорте, протоколах и т.п.

  - теряют обратную совместимость
  - документация в разных местах
  - переходят из команды в команду
  - не работают в одном контесте
    - конфликтуют бины (спринг, у спринга контекст, в контексте бины, у бинов имена, имена конфликтуют)
    - каждый плодит потоки и рулит ими, как хочет
- Сделали синтетику, чтобы собрать в одном контексте
- Сделали POM как средз версий КМов
- Стали проверять Java API на обратную совместимоть
- Стали проверять XSD-схем spring-а на обратную совместимость (потому что без Spring-Boot)
- Сделали приложение, которое автоматизирует последние 4 описанных выше шага
  - формирует POM
  - собирает приложение, в которое подключены все КМы в едином контексте
  - проверяет обратную совместимость Java API
  - проверяет XSD-схемы на обратную совместимость
  - рисует отчёт по результатам
  - сохраняет историю всех изменений и результаты всех проверок
- Добавили новые проверки
  - строем дерево зависимостей (чтобы убедиться, что в Nexus всего хватает)
  - проверяем наличие SNAPSHOT-версий
- Добавили наблюдение за Nexus на наличие новых версий библиотек
  - видим новую версию (не alpha, не beta, не test и не SNAPSHOT) – добавляем в новый POM
  - оказалось, что не всё можно добавлять в POM
- Появилось больше одного одновременно живущих релиза
- Добавили рассылку писем на ВП каждого КМа спросьбой заполнить релизную информацию по новой версии
  - помогло разруливать, какая версия в какой релиз платформы
  - помогло фильтровать ненужные версии либ
  - появилось документальное оправдание очередной доработки – Jira Issue
- В планах создание Личного Кабинета разработчика КМ
  - авторизация (понятно, кто вносит изменения)
  - видно статус проверок новой версии КМ + отчёт по результатам
  - видно историю версий КМ, историю POM
- Из команды ушёл ключевой разработчик
  - быстрое погружение новых разработчиков в работу приклада
  - начала появляться документация
  - остались белые пятна
  - потерялось "виденье продукта" и дальнейший путь развития

## Итоговое приложение
- формирует POM
- собирает приклад со всеми КМ-ами
- проверяет КМ-ы на обратную совместимость
- хранит историю результатов
- хранит историю изменений
- хранит релизную информацию
- хранит информацию обо всех КМ-ах, контакты разрабов – нужно актуализировать
- сканирует Nexus на наличие свежих версий
- делает рассылку и запрашивает релизную инфу
- обслуживает одновременно несколько релизов
- "Своё, родное" – безграничный потенциал возможностей

- разворачивается на отдельном сервере
- требует базу данных
- требует поддержки (чистка памяти, устранение проблем при рассылке писем)
- непрозрачен для разработчика КМ – чёрная дыра между публикацией новой версией библиотеки и публикацией нового POM с этой версией библиотеки
- GUI для администратора
- если делать GUI для потребителей (разработчики КМ-ов), нужна авторизация – инструмент перерастает в отдельный полноценный внутренний сервис
- безграничный потенциал превращается в бездонный бэклог на бесконечное количество человекочасов

## Всё это может Git + Jenkins
- хранить POM в текущем состоянии (список версий)
- хранить информацию о КМ-е (в комментарии внутри POM)
- хранит историю изменений каждого КМ и всего POM
- можно собрать приложение с текущим POM
- можно сравнивать верии библиотек Git-ом и проверять обратную совместимость и т.п.

- вместо сканирования Nexus и рассылки писем – изменение через PR
- разные команды разрабов КМ от каждого сервиса видят чужие изменения, могут на них влиять
- вместо отдельного сервера и приложения, которое собирает приложение – автоматический запуск Jenkins джобы по PR
- не нужен GUI (есть Bitbucket и Jenkins)
- не нужна авторизация (она уже есть в Bitbucket и Jenkins)
- для каждого релиза – отдельная релизная ветка

## Мораль
- протестить множество сервисов в одном флаконе можно
- можно сделать это сложным путём, а потом упростить
- можно воспользоваться чужим горьким опытом и сделать проще сразу
