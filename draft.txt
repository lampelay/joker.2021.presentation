

Рабочее название доклада звучит как
Shaken, not stirred - bunch of distributed teams in the single Spring Context

test 100500

300+ - teams 
50+ - microservices

// TODO
- Саша со своей стороны посмотрит презенташки - которые воткнули уровнем предоставления инфо
- Что и как мы можем выносить наружу (Протокол WorkFlow) - после полного текста презентации просто самим вычитать и смотреть
- Найти контакты через кого кидаем на Joker - DONE
- Найти категорию (тема) в которой рассказывать на Joker - 
	Operations:
	Опыт эксплуатации и сопровождения больших систем на Java
-  



Примеры презентаций
Creating Groovy DSLs that Developers Can Actually Use
https://www.infoq.com/presentations/groovy-dsl-mars/



1. Микросервисы для бизнеса подключаются через отдельные Spring Beans
-- на стороне бизнеес-приложения это клиентское????? взаимодействие
-- клиентское взаимодействие через HTTP (как правило), или TCP (немного)

2. Каждый микросервис предоставляет одна команда

3. Какие ключевые моменты увеличивали хаос
выравнивать всех более 50 команд,
разная скорость релизов,
команды географически распределны 
в разных часовых поясах
нужно подключать
???
???
- оправдание КМов? нудно много подробностей!!!
- прийти за историей к Саше Абросимову, Денису
- КМы элементарная инфраструктурная транспортная логика и она единообразна и не нужна на уровне бизнес приложения


3. Когда не было выравнивания с какимим проблемами столкнулись
-- не стартует Spring Context
-- коллизия по именам бинов
-- минимальное количество тестов????
-- Бизнесовым командам требуется подключать N зависимостей и отслеживать их изменение номеров версий
-- Несколько версий в проде
-- несколько каналов и т.п.
-- 



// TODO  Саша напиши историю
- рассказать историю и последовательностей шагов, как пришли к первому решению




4. Первый подход к снаряду
Pros
-- выделена отдельная команда
-- организовывала и синхронизировала остальные микросервисные команды
-- получали надлежащее качество - КМов
-- появился pom bom - бизнес команда подключает единственную зависимость, не парится с пачкой
-- бизнесовые команды привыкли и приняли удобство подключения
-- выкрестализовывание примера для бизнес команд
-- ???
-- ???

Cons
-- долгий процесс пинания команд, каждая в своем релизном цикле, рассинхрон
-- необязательность и не требуемая????
-- появилась иллюзия, что эта команда полностью отвечает за поставку ане команда ТСов
-- разруливание в полуручном режиме коллизий, сведенеие нескольких команд в одном диалоге
-- команда КМа явно не видит проблем и коллизий!!
-- ??



5. Описать новый подход - Blinding Lights
-- Чтобы команда микросевиса попала, а бизнесу предоставляется pom bom


# Преза

## История
---
  КМ:
  - работа с Java API вместо разнообразия транспортных протоколов

  Но:
  - теряют обратную совместимость
  - документация в разных местах
  - переходят из команды в команду
  - не работают в одном контесте
    - конфликтуют бины (спринг, у спринга контекст, в контексте бины, у бинов имена, имена конфликтуют)
    - каждый плодит потоки и рулит ими, как хочет
- Сделали синтетику, чтобы собрать в одном контексте
- Сделали POM как средз версий КМов
- Стали проверять Java API на обратную совместимоть
- Стали проверять XSD-схем spring-а на обратную совместимость (потому что без Spring-Boot)
- Сделали приложение, которое автоматизирует последние 4 описанных выше шага
  - формирует POM
  - собирает приложение, в которое подключены все КМы в едином контексте
  - проверяет обратную совместимость Java API
  - проверяет XSD-схемы на обратную совместимость
  - рисует отчёт по результатам
  - сохраняет историю всех изменений и результаты всех проверок
- Добавили новые проверки
  - строем дерево зависимостей (чтобы убедиться, что в Nexus всего хватает)
  - проверяем наличие SNAPSHOT-версий
- Добавили наблюдение за Nexus на наличие новых версий библиотек
  - видим новую версию (не alpha, не beta, не test и не SNAPSHOT) – добавляем в новый POM
  - оказалось, что не всё можно добавлять в POM
- Появилось больше одного одновременно живущих релиза
- Добавили рассылку писем на ВП каждого КМа спросьбой заполнить релизную информацию по новой версии
  - помогло разруливать, какая версия в какой релиз платформы
  - помогло фильтровать ненужные версии либ
  - появилось документальное оправдание очередной доработки – Jira Issue
- В планах создание Личного Кабинета разработчика КМ
  - авторизация (понятно, кто вносит изменения)
  - видно статус проверок новой версии КМ + отчёт по результатам
  - видно историю версий КМ, историю POM
- Из команды ушёл ключевой разработчик
  - быстрое погружение новых разработчиков в работу приклада
  - начала появляться документация
  - остались белые пятна
  - потерялось "виденье продукта" и дальнейший путь развития

## Итоговое приложение
- формирует POM
- собирает приклад со всеми КМ-ами
- проверяет КМ-ы на обратную совместимость
- хранит историю результатов
- хранит историю изменений
- хранит релизную информацию
- хранит информацию обо всех КМ-ах, контакты разрабов – нужно актуализировать
- сканирует Nexus на наличие свежих версий
- делает рассылку и запрашивает релизную инфу
- обслуживает одновременно несколько релизов
- "Своё, родное" – безграничный потенциал возможностей

- разворачивается на отдельном сервере
- требует базу данных
- требует поддержки (чистка памяти, устранение проблем при рассылке писем)
- непрозрачен для разработчика КМ – чёрная дыра между публикацией новой версией библиотеки и публикацией нового POM с этой версией библиотеки
- GUI для администратора
- если делать GUI для потребителей (разработчики КМ-ов), нужна авторизация – инструмент перерастает в отдельный полноценный внутренний сервис
- безграничный потенциал превращается в бездонный бэклог на бесконечное количество человекочасов

## Всё это может Git + Jenkins
- хранить POM в текущем состоянии (список версий)
- хранить информацию о КМ-е (в комментарии внутри POM)
- хранит историю изменений каждого КМ и всего POM
- можно собрать приложение с текущим POM
- можно сравнивать верии библиотек Git-ом и проверять обратную совместимость и т.п.

- вместо сканирования Nexus и рассылки писем – изменение через PR
- разные команды разрабов КМ от каждого сервиса видят чужие изменения, могут на них влиять
- вместо отдельного сервера и приложения, которое собирает приложение – автоматический запуск Jenkins джобы по PR
- не нужен GUI (есть Bitbucket и Jenkins)
- не нужна авторизация (она уже есть в Bitbucket и Jenkins)
- для каждого релиза – отдельная релизная ветка

## Мораль
- протестить множество сервисов в одном флаконе можно
- можно сделать это сложным путём, а потом упростить
- можно воспользоваться чужим горьким опытом и сделать проще сразу




---

# Рассмотрение с точки зрения проблем, задач, решений и инструментов

У СБЕРа есть СБОЛ, 
у СБОЛа есть фичи, 
каждая фича это отдельный сервис, 
общие части работы сервисов делают тех.сервисы (или Платформа), 
тех.сервисы работают через клиентские модули (КМ): набор Java-библиотек, которые умеют правильно общаться с тех.сервисами, их ещё можно назвать фасадами.

Фишка КМов:
 - потребитель работает с Java API
 - не нужно думать о транспорте, протоколах, кэшах и т.п.
 - потребитель знает о версии Java-библиотеки, но не думает о версии тех.сервиса

- Проблема 0: Сервисов много и мы хотим убедиться, что все со всеми совместимы при компиляции и корректно работают в рантайме
  Решение: Написать одно приложение, в которое подключить все библиотеки и убедиться в том, что:
            - оно скомпилировалось
            - Spring-контекст поднялся
            - bean каждого сервиса продёргивается и возвращает ожидаемый результат
            
- Проблема 1: Сервисов много, документация есть, но разрознена, а потребителю нужно получить актуальную версию каждой библиотеки
  Первое, что пришло в голову: Мы подключили все библиотеки в одном приложении, то есть в зависимостях этого приклада как раз актуальный стабильный срез версий, пусть потребители оттуда берут.
  Нормальное решение: Собрать срез всех версий библиотек в BOM и распространять как один артефакт

- Проблема 2: Вышла новая версия библиотеки сервиса N и наше приложение перестало компилироваться. Оказалось, что удалили один метод.
  Решение: Добавить на уровне формирования BOM проверку библиотек на обратную совместимость Java API
  Варианты:
    - japi-compliance-checker – написана на Perl, работает на уровне sources. Были проблемы с проверкой изменений в дженериках.
    - revapi – написана на Java, вызывается из Java, распознаёт изменения в дженериках
    - sigtest – (нужно рассмотреть)
    - т.п.

- Проблема 2.1: Проверка обратной совместимости ругается на реализацию, которую потребитель не должен использовать.
  Решение: Разделить КМы на API jar и IMPL jar. На методы API можно завязываться, они должны сохранять обратную совместимость. IMPL могут меняться, их мы проверять не будем и на них нельзя завязываться.

