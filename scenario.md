# Обратная совместимость, инструменты и подходы для контроля над dependency hell

При разработке проекта нам обычно не хватает только Java и только Maven/Gradle. Мы используем множество дополнительных библиотек и инструментов, которые упростят нам жизнь и ускорят написание работающего приклада.

Каждая сторонняя либа – это зависимость. А где у нас живут зависимости?
Правильно. В `pom.xml` или `build.gradle`.

Когда модуль в приложении один, всё понятно. Файл с зависимостями один, трудно запутаться.

Но наше приложение развивается, логика усложняется, появляются новые модули.
Каждый из них использует одни и те же библиотеки для тестов, для REST и т.п.

## Шаг первый: Dependency Management

Можно конечно просто скопипастить зависимости и всё будет работать. Но в какой-то момент нам приспичит обновить версию какой-нибудь библиотеки. Не ходить же теперь по всем модулям и up-ать версию? Мы выделяем корневой модуль, который становится parent-ом для остальных, заводим в нём секцию `<dependencyManagement />` в случае Maven. (***TODO*** Как это делается в Gradle???). В эту секцию заносятся зависимости с указанием версии, а в дочерних модулях в секции `<dependencies />` версию больше указывать не нужно.


```xml
<!-- вставка куска кода -->

```

Вроде удобно.

Время идёт, одного приложения нам мало, мы начинаем писать второе. Во втором приложении всё точно так же устроено: корневой модуль с `<dependencyManagement />` и потомки без версий в зависимостях.

И вот опять нам хочется чего-то нового – обновляем версии. Теперь что, бегать по проектам и менять версии библиотек? Или это как-то решается более красиво?

А если у нас проектов не два и даже не три? Возможно мы большая компания. Или не очень большая, но хотим стать большой. У больших компаний большой список проблем и задач. Не хочется добавлять к ним ещё и беготню по проектам ради апдейта версии Spring-Boot-а. А таких Spring-Boot-ов, то есть разных библиотек, очень большое количество. И не только внешних, но и собственных, разработанных внутри компании.

Как вариант можно написать документ, в котором перечислить все сторонние и внутренние библиотеки и указать, какие версии нужно использовать. А можно это автоматизировать.

## Шаг первый с половиной: BOM-артефакт

Для такого существует BOM. Это POM артефакт, в котором присутствует только секция `<dependencyManagement />`. Его можно подключить в свой проект в свой `<dependencyManagement>` с указанием `<scope>import</scope>`. В этот BOM мы положим все библиотеки, которые мы хотим шарить между проектами, и будем выпускать и версионировать. При сборке всё, что было в BOM, "развернётся" в `pom.xml` нашего проекта.

```xml
<!-- вставка куска кода -->

```

Получается, мы чуть смягчаем головную боль обновления версий. Теперь вместо моножества версий кучи библиотек достаточно заменить одну версию одной зависимости. В том числе это упростит жизнь разработчикам новых проектов у нас в компании.

У того же Spring-Boot, помимо `spring-boot-starter-parent`, существует и BOM артефакт – `spring-boot-dependencies`.

В рамках Сбера, а точнее в рамках бэковой части Сбербанк-Онлайн, мы как раз выпускаем BOM-артефактом, в котором собираем сторонние библиотеки и внутренние библиотеки для работы с платформой Сбера.

Место для управления версиями библиотек мы выбрали. Обновляться стало проще. 


## Шаг второй: контроль обратной совместимости Java API подключённых зависимостей

При очередно обновлении очередной библиотеки большинство проектов продолжили работать, как работали, но некоторые перестали компилироваться. Что случилось? Правильно, новая версия библиотеки больше не совместима с нашим кодом. 

Хорошо, что компилятор это подсветил. Мы поняли свою ошибку и откатили версию обратно. В случае кровавого enterprise-а мы прикипели на пересборку множества проектов. 

Хотелось бы избежать ненужных телодвижений. Можно конечно для верности при каждом обновлении BOM запускать компиляцию и тесты во всех проектах, которые от него зависят. Это супер-надёжно, но и супер-затратно. К тому же, будем честны, не все проекты хорошо покрыты тестами. 

Необходимо контролировать обратную совместимость Java-API всех библиотек, котоые мы несём в BOM.

Маленькое отступление. Совместимость бывает разная: полная, прямая, обратная. 

Полная совместимость – это, например, между JVM от разных поставщиков (OpenJDK, Oracle, IBM), при замене одной на другую приложение должно работать одинаково. 

В данный момент нас интересует обратная совместимось.

Обратная совместимость – это сохранение работоспособности при замене старой версии компонента на новую.

Совместимость бывает на уровне байт-кода (binary compatibility), то есть когда замена `jar`-ки в папке `lib` на новую версию на рабочем сервере позволит продолжить работу без пересборки приложения.

Совместимость на уровне исходного кода (sources compatibility) гарантирует, что наше приложение **скомпилируется** при обновлении зависимости.

Пример **сохранения** обратной совместимости:

```java
/** v1.0 */
class MyLittleSerivce {
  public List<String> getSomeRandomWords() { /* ... */ }
}

/** v1.1 */
class MyLittleSerivce {
  public List<String> getSomeRandomWords() { /* ... */ }

  // добавили новый метод
  public List<Integer> getSomeNumbers() { /* ... */ }
}
```

Пример **потери** обратной совместимости:

```java
/** v1.0 */
interface MyLittleSerivce {
  public List<String> findSomeWords();
}

/** v1.1 */
interface MyLittleSerivce {
  // изменилась сигнатура метода – добавили аргумент
  public List<String> findSomeWords(String searchPattern);
}

// или 

/** v1.1 */
class MyLittleSerivce {
  public List<String> getSomeRandomWords() { /* ... */ }

  public List<Integer> getSomeNumbers() { /* ... */ }
}

/** v1.2 */
class MyLittleSerivce {  
  // метод getSomeRandomWords исчез

  public List<Integer> getSomeNumbers() { /* ... */ }
}
```

Здесь хотелось бы отослать зрителей на доклад Михаила Ершова о совместимости в Java. Там много примеров, подкреплённых теорией.

[Михаил Ершов — Разработка совместимого API](https://www.youtube.com/watch?v=EgOZSr-Uc3w).

В рантайме есть `classpath`. Туда при старте приложения попадает только одна версия каждого класса или интерфейса. Наш приклад и наши зависимости могут быть завязаны на одну и ту же библиотеку. Только мы затащили версию 3, а наша зависимость – версию 2. В итоге в `classpath` попала версия 3, которая несовместима с версией 2, и наша зависимость перестала работать. При компиляции мы этого не увидели, потому что компилировали только своё прилжение. А в unit-тестах мы этого не отловили, потому что эту зависимость для теста мы за**mock**али, ибо не за чем нам тестировать чужое добро.

Хорошо, что предки оставили нам множество инструментов для контроля обратной совметсимости.

Вот те, которые мы попробовали и применили на практике.

- japi-compliance-checker

  Написано на `perl`.
  Последний релиз в начале 2018 года. Разработка продолжается.
  В нашей практике не отследил обновления, связанные с параметризованными классами (Generics).

- revapi (на нём пока остановились)

  Написан на java, вызывается из Java.
  Может анализировать не только Java.
  Последние обновления очень свежие.
  Пришлось написать свой Freemarker шаблон для вывода отчётов. Возможно, мы его за**pull-request**им как-нибудь.

- japicmp

  Написано на Java.

- sigtest // TODO описать возможности, удобство и развитие
  
  Инстумент от "самой" Oracle. 

Принцип использования у всех примерно одинаковый:

- подкладываем инструменту две `jar`-ки
- получаем отчёт о сравнении
- принимаем решение, обновлятся или нет

С Java-API разобрались, его мы теперь контролируем.

## Шаг третий: контроль обратной совместмости конфигурации зависимостей

А что на счёт конфигурации? В **spring**овом проекте, как минимум, есть файл `application.properties` (или `application.yaml`), в котором содержатся параметры для некоторых spring-boot-стартеров.

Тут мы можем подстелить себе соломку и попытаться проверять такую штуку, как `spring-configuration-metadata.json`. Этот обычно содержится в spring-boot-стартерах, если разработчик стартера подключил плагин `spring-boot-configuration-processor`. За счёт него IDE подсказывает, что и как писать в `application.properties`.

Определим несколько простых правил, которые мы будем считать признаками нарушения обратной совместимости:

- Добавление нового параметра без `default`-ного значения
- Изменение типа данных параметра

Также выделаются несколько правил, которые не "ужас-ужас", но на которые стоит обращать внимание:

- удаление параметра
- изменение `default`-ного значния

Для своих задач мы написали простецкий "проверятор" файла `spring-configuration-metadata.json` на основе этих правил. Не то, чтобы он кардинально ситуацию и спасло тысячи жизней и человекочасов, но находить место ошибки стало несколько проще.

Если речь идёт о "чистом" спринге (для old-фагов), в котором контекст конфигурируется на `xml`-ках, на помощь приходит библиотека [SOA Model (predic8)](https://github.com/membrane/soa-model), которая позволяет проверять обратную совместимость `xsd`-схем. Это не единственная библиотека для таких целей. При желании можно нагуглить то, что будет удобно.

## Шаг четвёртый (а может, и первый): тесты

Вот мы дошли до рантайма. Помимо `classpath` в приложении есть ещё одно общественное место – это контекст (например, Spring). В контекст лезут все, кому не лень. И наши собственные бины, и бины из стартеров сторонних библиотек. И все они не должны друг с другом конфликтовать. А они любят конфликтовать, напрмиер, своими именами.

Что нам помогает контролировать работоспособност? Конечно же тесты. И желательно интеграционные, в которых классы из сторонних зависимостей не будут за**mock**аны, а будут работать по-честному. В таких тестах изменения, "ломающие" совместимость, будет гораздо проще отловить.

